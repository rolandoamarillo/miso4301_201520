pre {
  "Running Visulization Transformation".println();
}

post {
	CreateDependecies();
	"Done".println();
	
	
}

//Raiz
rule Segment2NodoPrincipal
transform t: kdmMicro!CodeModel
to o: target!Aplicacion{
  guard : t.name <> "externals"
  o.name = t.name;
  o.EjectClusterEJB();
}

/*calcula dependencia entre clusters*/
operation target!Cluster CalculateClusterDependencies(clusterSet: Set){
		var A = self;
		var clasesA = self.GetClasesCluster()->asSet();
		
		for(B in clusterSet){
			var clasesB = B.GetClasesCluster()->asSet();
			var intersect = new Set;
			intersect.addAll(clasesA->select(c|clasesB->includes(c)));
			
			//var value = new Real;
			//value = 0.0;//((intersect->size()->asDouble())/(A->size()->asDouble())).max(((intersect->size()->asDouble())/(B->size()->asDouble())));
			
			var cl = new target!Arco();
			var tipo = new target!Dependencia();
			cl.target = B;
			cl.source = A;
			cl.tipos.add(tipo); 
			//cl.value = value;
			self.hijos.add(cl);
		}
}

//obtiene la lista de clases de un cluster
operation target!Cluster GetClasesCluster(): Sequence{
	var listClases = new Sequence();
	var paquetes = self.hijos.select(x | x.isTypeOf(target!Paquete));
	for(pk in paquetes)
	{
		var clases = paquetes.hijos.select(x | x.isTypeOf(target!Clase));
		for(cl in clases)
		{
			listClases.add(cl);
		}
	}
	
	return listClases;
}

/*Arma cluster de acuerdo a relaciones entre EJBs y los entities*/
operation target!Aplicacion EjectClusterEJB() : Sequence{

 	var classes = kdmMicro!CodeModel.allInstances().first().getAllContents()->select(class|class.isTypeOf(kdmMicro!ClassUnit) or class.isTypeOf(kdmMicro!InterfaceUnit) or class.isTypeOf(kdmMicro!TemplateUnit));
	var relations = kdmMicro!ClassLevelRelation.allInstances();
	var clusterTool = new Native("clusterer.EJBClusterer");
	
	var ejbs = new Set;
	var entities = new Set;
	
	for(c in classes){
		if (c.containsEntity()){
			entities.add(c);
		}
		else if(c.containsEJB()){
			ejbs.add(c);
		}
	}
	
	clusterTool.constructGraph(classes->asSet(),relations->asSet());
	var clusterSet = clusterTool.makeCluster(ejbs,entities);
	    
    for(cluster in clusterSet){
    	var nodoCluster = new target!Cluster();
    	nodoCluster.name = cluster.name;
    	for (pk in cluster.hijos)
    	{
    		var nodoPaquete = new target!Paquete();
    		nodoPaquete.name = pk.name;
    		
    		for(cls in pk.hijos)
    		{
    			var nodoClase = new target!Clase();
    			nodoClase.name=cls.name;
    			nodoPaquete.hijos.add(nodoClase);
    		}
    		
    		nodoCluster.hijos.add(nodoPaquete);
    	}
    	
    	//nodoCluster.CalculateClusterDependencies(clusterSet);
    	self.hijos.add(nodoCluster);
    }
}

//Crea las dependencias para cada clase en el modelo
//relaciones - arcos
//metricas
operation CreateDependecies(){

	var classLR = kdmMicro!ClassLevelRelation.allInstances();
	var nodosClases = target!Nodo.allInstances().select(x | x.isTypeOf(target!Clase));
	
	for(nodo in nodosClases)
	{
		nodo.GetRelationsClass(classLR, nodosClases);
		nodo.CreateMeasuresClasses();
	}	
}

//asocia metricas de las clases
operation target!Nodo CreateMeasuresClasses(){
	//buscar pesos de las metricas por clases...
	if(kdmMicro!MofElement.allInstances().exists(x | x.element.isTypeOf(kdmMicro!ClassUnit) and x.element.name == self.name))
	{
		var mofElement = kdmMicro!MofElement.allInstances().select(x | x.element.isTypeOf(kdmMicro!ClassUnit) and x.element.name == self.name).first();
		var measurant = mofElement.measurant;
		
		for(m in measurant)
		{
			var met = new target!Metrica();
			met.valor = m.value; 
			if(m.measure.isDefined())
			{
				met.SetTipoMetrics(m.measure);
			}
			self.metricas.add(met);
		}
	}
}

//Obtiene las relaciones de cada clase 
operation target!Nodo GetRelationsClass(classLR: Sequence, nodosClases: Sequence){
	var relations = classLR.select(x | x.`from`.name == self.name);
	
	for(rel in relations){
		var package = rel.`from`.eContainer();
	    var dep = new target!Arco();
	    
	    var ClaseTarg = nodosClases.select(x | x.name == rel.`to`.name).first();
	    dep.target =  ClaseTarg;
	    dep.source = self;
	    
	    dep.CreateMeasuresRelations(rel);
	    
	    for(t in rel.typeRelations){
	    	dep.AddTypeRelation(t);
	    }
	    
		self.hijos.add(dep);
	}
}

/*Adiciona a un arco el tipo de relacion segun modelo visualizacion*/
operation target!Arco AddTypeRelation(relation: kdmMicro!TypeRelation){
	
	if(relation.name == "Containment")
	{
		var tipoRel = new target!Composicion();
		self.tipos.add(tipoRel);
	}
	else if(relation.name == "Uses")
	{
		var tipoRel = new target!Dependencia();
		self.tipos.add(tipoRel);
	}
	else if(relation.name == "Implements")
	{
		var tipoRel = new target!Generalizacion();
		self.tipos.add(tipoRel);
	}
	else if(relation.name == "Extends")
	{
		var tipoRel = new target!Generalizacion();
		self.tipos.add(tipoRel);
	}
}

//asocia metricas de relaciones - arcos
operation target!Arco CreateMeasuresRelations(relation: kdmMicro!ClassLevelRelation){
	//buscar pesos de las metricas por clases...
	if(kdmMicro!MofElement.allInstances().exists(x | x.element.isTypeOf(kdmMicro!ClassLevelRelation) and x.element.equals(relation)))
	{
		var mofElement = kdmMicro!MofElement.allInstances().select(x | x.element.isTypeOf(kdmMicro!ClassLevelRelation) and x.element.equals(relation)).first();
		var measurant = mofElement.measurant.select(x | x.isTypeOf(kdmMicro!DimensionalMeasurement));
		
		//measurant.println();
		for(m in measurant)
		{
			var met1 = new target!Metrica();
			met1.SetTipoMetrics(m.measure);
			met1.valor = m.value.asDouble();
			
			self.metricas.add(met1);
		}
	}
}

//Obtiene la lista de todos los elementos que conetiene en el source
operation kdmMicro!ModelElement getAllContents(): Sequence{
	var set = new Sequence;
	set.addAll(self.eContents());
	for (e in  self.eContents()){
		set.addAll(e.getAllContents());
	}
	return set;
}

// identifica si un ClassUnit esta en el paquete de externos
// para no inlcuirlas en las relaciones
operation ExistsInExternals(lista: Sequence,item: kdmMicro!CodeItem): Boolean{
	if(lista.exists(a | a.equals(item)))
	 return true;
	else
	 return false; 	
}

//obtiene el tipo de metrica
operation target!Metrica SetTipoMetrics(tipoMeasure: kdmMicro!Measure){
	
	if(tipoMeasure.isTypeOf(kdmMicro!NumberOfUsesMeasure))
	{
		self.tipo = target!TipoMetrica#NumberOfUses;
	}
	else if(tipoMeasure.isTypeOf(kdmMicro!NumberOfContainmentsMeasure))
	{
		self.tipo = target!TipoMetrica#NumberOfContainments;
	}
	else if(tipoMeasure.isTypeOf(kdmMicro!CalculatedCouplingMeasure))
	{
		self.tipo = target!TipoMetrica#CalculatedCoupling;
	}
	else if(tipoMeasure.isTypeOf(kdmMicro!CouplingBetweenObjectsMeasure))
	{
		self.tipo = target!TipoMetrica#CouplingBetweenObjects;
	}
	else if(tipoMeasure.isTypeOf(kdmMicro!WeightedMethodsPerClassMeasure))
	{
		self.tipo = target!TipoMetrica#WeightedMethodsPerClass;
	}
}

operation kdmMicro!CodeItem containsEntity(): Boolean
{
	return self.codeRelation.select(hasValue | hasValue.isTypeOf(kdmMicro!HasValue) and hasValue.annotation.size() > 0 and hasValue.`to`.name.equalsIgnoreCase("Entity") ).size > 0;
}

operation kdmMicro!CodeItem containsEJB(): Boolean
{
	return self.codeRelation.select(hasValue | hasValue.isTypeOf(kdmMicro!HasValue) and hasValue.annotation.size() > 0 and (hasValue.`to`.name.equalsIgnoreCase("Stateless") or hasValue.`to`.name.equalsIgnoreCase("Stateful") or hasValue.`to`.name.equalsIgnoreCase("Remote") ) ).size > 0;
}
