pre {
  "Running Visulization Transformation".println();
}

post {
	CreateDependecies();
	"Done".println();
}

//Raiz
rule Segment2NodoPrincipal
transform t: source!CodeModel
to o: target!Aplicacion{
  guard : t.name <> "externals"
  o.name = t.name;
  o.hijos = EjectCluster();
}

operation EjectCluster() : Sequence{
    var lista = new Sequence;
    
    var count = 0;
    var modExt = source!CodeModel.allInstances().select(x| x.name = "externals").first();
	var sonsExt = modExt.getAllContents();
	
   	var segment = source!CodeModel.allInstances().first();
	var classes = source!Segment.allInstances().first().getAllContents()->select(e| e.isTypeOf(source!ClassUnit) and not ExistsInExternals(sonsExt, e));
	
	var clusterTool = new Native("clusterer.MSTCluesterCalculation");
	
	//buscar pesos de las relaciones por clases...
	var mofElements = source!MofElement.allInstances().select(x | x.element.isTypeOf(source!ClassLevelRelation));
	
	clusterTool.constructGraph(classes->asSet());
	for(elem in mofElements)
	{
	  var relation = elem.element;	
	  var measurant = elem.measurant;
	  //measurant.println();
	  var coupling = measurant.select(x| x.measure.isTypeOf(source!CalculatedCouplingMeasure)).first();
	  var peso = 1;
	  	
	  if(coupling.value > 0)
	    peso = coupling.value;
	 	
	  clusterTool.addClassLevelRelation(relation, peso.asInteger()); 
	}
	
	var k = 1;
		
	var str = System.User.promptInteger("Number of Clusters", k.asInteger());
	k = str.asInteger();
	
	var clusterSet = clusterTool.getClusters(k);
	    
	for (cluster in clusterSet){
      var nodoCluster = new target!Cluster();
  	  count = count + 1;
  	  nodoCluster.name ="Cluster" + count;
  	   
  	  for(c in cluster){
  	     var pkg = nodoCluster.CreatePackages(c);
  	     
  	     var nodoClasses = new target!Clase();
  		 nodoClasses.name = c.name;
  		 nodoClasses.tipo =  target!TipoElemento#CLASS;
  		 pkg.hijos.add(nodoClasses);
      }
      
     lista.add(nodoCluster);
    }
    
   return lista;
}

//Crea los paquetes por cluster
operation target!Cluster CreatePackages(item: source!CodeItem){     
	//se obtiene el paquete al cual pertenece la clase
  	var package = item.eContainer();
  	      
  	var nodoPack = self.hijos.select(x | x.name == package.name).first();
	if(nodoPack.isDefined()){
		return nodoPack;
	}
	else{
		var nodoPack2 = new target!Paquete();
		nodoPack2.name = package.name;
		nodoPack2.tipo = target!TipoElemento#PACKAGE;
		self.hijos.add(nodoPack2);
		
		return 	nodoPack2;
	}
}

//Crea las dependencias para cada clase en el modelo
//relaciones - arcos
//metricas
operation CreateDependecies(){

	var classLR = source!ClassLevelRelation.allInstances();
	var nodosClases = target!Nodo.allInstances().select(x | x.isTypeOf(target!Clase));
	
	for(nodo in nodosClases)
	{
		nodo.GetRelationsClass(classLR, nodosClases);
		nodo.CreateMeasuresClasses();
	}	
}

//asocia metricas de las clases
operation target!Nodo CreateMeasuresClasses(){
	//buscar pesos de las metricas por clases...
	if(source!MofElement.allInstances().exists(x | x.element.isTypeOf(source!ClassUnit) and x.element.name == self.name))
	{
		var mofElement = source!MofElement.allInstances().select(x | x.element.isTypeOf(source!ClassUnit) and x.element.name == self.name).first();
		var measurant = mofElement.measurant;
		
		for(m in measurant)
		{
			var met = new target!Metrica();
			met.valor = m.value; 
			if(m.measure.isDefined())
			{
				met.SetTipoMetrics(m.measure);
			}
			self.metricas.add(met);
		}
	}
}

//Obtiene las relaciones de cada clase para mapear a dependencias
operation target!Nodo GetRelationsClass(classLR: Sequence, nodosClases: Sequence){
	var relations = classLR.select(x | x.`from`.name == self.name);
	
	for(rel in relations){
		var package = rel.`from`.eContainer();
	    var dep = new target!Arco();
	    
	    var ClaseDep = nodosClases.select(x | x.name == rel.`to`.name).first();
	    dep.target =  ClaseDep;
	    dep.CreateMeasuresRelations(rel);
	    for(t in rel.typeRelations){
	    	var tipoRel = new target!TipoArco();
	    	tipoRel.name = t.name;
	    	dep.tipos.add(tipoRel);
	    }
	    
		self.hijos.add(dep);
	}
}

//asocia metricas de relaciones - arcos
operation target!Arco CreateMeasuresRelations(relation: source!ClassLevelRelation){
	//buscar pesos de las metricas por clases...
	if(source!MofElement.allInstances().exists(x | x.element.isTypeOf(source!ClassLevelRelation) and x.element.equals(relation)))
	{
		var mofElement = source!MofElement.allInstances().select(x | x.element.isTypeOf(source!ClassLevelRelation) and x.element.equals(relation)).first();
		var measurant = mofElement.measurant;
		
		//measurant.println();
		for(m in measurant)
		{
			var met1 = new target!Metrica();
			met1.SetTipoMetrics(m.measure);
			met1.valor = m.value.asDouble();
			
			self.metricas.add(met1);
		}
	}
}

//Obtiene la lista de todos los elementos que conetiene en el source
operation source!ModelElement getAllContents(): Sequence{
	var set = new Sequence;
	set.addAll(self.eContents());
	for (e in  self.eContents()){
		set.addAll(e.getAllContents());
	}
	return set;
}

// identifica si un ClassUnit esta en el paquete de externos
// para no inlcuirlas en las relaciones
operation ExistsInExternals(lista: Sequence,item: source!CodeItem): Boolean{
	if(lista.exists(a | a.equals(item)))
	 return true;
	else
	 return false; 	
}

//obtiene el tipo de metrica
operation target!Metrica SetTipoMetrics(tipoMeasure: source!Measure){
	
	if(tipoMeasure.isTypeOf(source!NumberOfUsesMeasure))
	{
		self.tipo = target!TipoMetrica#NumberOfUses;
	}
	else if(tipoMeasure.isTypeOf(source!NumberOfContainmentsMeasure))
	{
		self.tipo = target!TipoMetrica#NumberOfContainments;
	}
	else if(tipoMeasure.isTypeOf(source!CalculatedCouplingMeasure))
	{
		self.tipo = target!TipoMetrica#CalculatedCoupling;
	}
	else if(tipoMeasure.isTypeOf(source!CouplingBetweenObjectsMeasure))
	{
		self.tipo = target!TipoMetrica#CouplingBetweenObjects;
	}
	else if(tipoMeasure.isTypeOf(source!WeightedMethodsPerClassMeasure))
	{
		self.tipo = target!TipoMetrica#WeightedMethodsPerClass;
	}
}